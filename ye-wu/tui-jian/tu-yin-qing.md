# 图引擎

### 背景

组内被交接若干推荐业务，如框词，相关搜索，联想词等，老大希望借着交接进行一波重构，使用tx的技术重做一遍，分配过来的任务就是设计通用的图引擎框架。

* 没有引擎框架下，代码是写成大坨的if else用于应对各个分支各个场景。经常会遇到的问题就是在a场景下改对了，但是在b场景下错了，需要触发大量的回归逻辑去验证是否影响了其他场景；且代码量过大不利于协作，因为很难分清分工，不光是召回，排序之间的分工，组内的分工也很难通过大坨代码来明确：有的同学可能只负责某一路或者某几路召回
* 有了引擎框架，相当于设计了马路和交通规则，车可以有规则有规律的通行。结合前面的问题，逻辑之间独立性更好，开发的时候可以只关注自己一小块内的逻辑，不用担心对其他业务的影响，因为引擎给做好了隔离；这样没有回归成本，交接和维护的效率更高，另外算子之间可以快速复用，实现逻辑copy，起到提高人效的结果



### 方案

业内通常有两种思路的引擎框架，一种是控制流思想，一种是数据流思想。

* 控制流思想：执行完a后执行b，执行完b后执行c和d，是一种边驱动的思路。控制流最后的配置表达大概率是一种森林或者森林的变体，即多个维度的二叉或者多叉树。树只能往下开叉但是不能合叉，这是与图的最大区别。数据放在一个总线数据结构里，简称sess。
  * 这种框架的好处是思路简单，逻辑清晰，因为可以非常直观的确认某个节点的执行时机，比如b就是在a执行完后执行的这样。所以无论开发还是调试，都会比较容易
  * 坏处也比较明显，天花板比较低。控制流思想下如果想要做一些耗时优化，其实只能通过手动调整节点的执行时机来实现一种短板原理的效果。当前实际业务中确实耗时大头不在业务上，所以如果业务简单可以通过控制流框架做。
  * 典型代表，go有一个web框架叫gin，alimama有一个框架叫orc。以及ali aios的tpp（这个可能比较有争议）
* 数据流思想：一种靠数据依赖驱动的执行方式，最后的配置表达式一种有向无环图。思路大概是a输出outputA，b输出outputB，c执行需要依赖outputA和outputB，那c就可以在a和b执行完成后自动执行。实际执行时候拓扑排序就可以，判定节点的deps然后deps为0的自动执行
  * 好处：耗时最优解，也是目前主流的思路
  * 坏处：开发调试都会比控制流复杂。最典型的问题，图到底怎么表达
  * 典型代表：机器学习的框架如tensorflow，pytorch都是类似；go的话有一个taskflow是个离线任务调度的实现。ali的aios底层有一个框架叫suez turing，本质就是tensorflow



### 目标

因为面临的交接任务比较多，所以需要设计一套能快速迭代，快速复用的引擎框架，另外排查效率要高，因为对于一个业务重构，排查问题可能比开发的时间成本更高。再有就是基础的性能要求等。h



### 思路



<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

